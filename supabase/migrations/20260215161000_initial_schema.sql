-- Kolony MVP initial schema
-- Authenticated users can read core tables.
-- Writes are restricted to operator/admin roles (except profile bootstrap).

create extension if not exists pgcrypto;

create type public.app_role as enum ('viewer', 'operator', 'admin');
create type public.agent_status as enum ('online', 'offline', 'busy', 'error');
create type public.command_status as enum (
  'draft',
  'queued',
  'dispatching',
  'executing',
  'completed',
  'failed',
  'cancelled'
);

create table public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  display_name text,
  role public.app_role not null default 'viewer',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table public.agents (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  external_id text unique,
  status public.agent_status not null default 'offline',
  capabilities jsonb not null default '[]'::jsonb,
  metadata jsonb not null default '{}'::jsonb,
  last_heartbeat_at timestamptz,
  created_by uuid references public.profiles(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint agents_name_not_blank check (length(trim(name)) > 0)
);

create table public.commands (
  id uuid primary key default gen_random_uuid(),
  agent_id uuid not null references public.agents(id) on delete restrict,
  instruction text not null,
  payload jsonb not null default '{}'::jsonb,
  status public.command_status not null default 'queued',
  priority smallint not null default 5,
  requested_by uuid not null references public.profiles(id),
  started_at timestamptz,
  completed_at timestamptz,
  error_message text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint commands_priority_range check (priority between 1 and 10),
  constraint commands_instruction_not_blank check (length(trim(instruction)) > 0)
);

create table public.command_results (
  id bigint generated by default as identity primary key,
  command_id uuid not null references public.commands(id) on delete cascade,
  chunk_index integer not null default 0,
  is_final boolean not null default false,
  output text not null,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now(),
  constraint command_results_chunk_index_non_negative check (chunk_index >= 0)
);

create table public.events (
  id bigint generated by default as identity primary key,
  event_type text not null,
  level text not null default 'info',
  agent_id uuid references public.agents(id) on delete set null,
  command_id uuid references public.commands(id) on delete set null,
  payload jsonb not null default '{}'::jsonb,
  occurred_at timestamptz not null default now(),
  created_at timestamptz not null default now(),
  constraint events_event_type_not_blank check (length(trim(event_type)) > 0)
);

create index agents_status_idx on public.agents (status);
create index agents_last_heartbeat_idx on public.agents (last_heartbeat_at desc);

create index commands_status_created_at_idx on public.commands (status, created_at desc);
create index commands_agent_created_at_idx on public.commands (agent_id, created_at desc);
create index commands_requested_by_created_at_idx on public.commands (requested_by, created_at desc);

create unique index command_results_command_chunk_uidx on public.command_results (command_id, chunk_index);
create index command_results_command_created_at_idx on public.command_results (command_id, created_at desc);

create index events_event_type_occurred_at_idx on public.events (event_type, occurred_at desc);
create index events_agent_occurred_at_idx on public.events (agent_id, occurred_at desc) where agent_id is not null;
create index events_command_occurred_at_idx on public.events (command_id, occurred_at desc) where command_id is not null;

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create trigger set_profiles_updated_at
before update on public.profiles
for each row execute function public.set_updated_at();

create trigger set_agents_updated_at
before update on public.agents
for each row execute function public.set_updated_at();

create trigger set_commands_updated_at
before update on public.commands
for each row execute function public.set_updated_at();

create or replace function public.current_app_role()
returns public.app_role
language sql
stable
security definer
set search_path = public
as $$
  select coalesce(
    (select role from public.profiles where id = auth.uid()),
    'viewer'::public.app_role
  );
$$;

create or replace function public.is_operator_or_admin()
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select public.current_app_role() in ('operator'::public.app_role, 'admin'::public.app_role);
$$;

create or replace function public.is_admin()
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select public.current_app_role() = 'admin'::public.app_role;
$$;

alter table public.profiles enable row level security;
alter table public.agents enable row level security;
alter table public.commands enable row level security;
alter table public.command_results enable row level security;
alter table public.events enable row level security;

-- Authenticated reads across core tables.
create policy "profiles_read_authenticated"
on public.profiles
for select
to authenticated
using (true);

create policy "agents_read_authenticated"
on public.agents
for select
to authenticated
using (true);

create policy "commands_read_authenticated"
on public.commands
for select
to authenticated
using (true);

create policy "command_results_read_authenticated"
on public.command_results
for select
to authenticated
using (true);

create policy "events_read_authenticated"
on public.events
for select
to authenticated
using (true);

-- Profile bootstrap and management.
create policy "profiles_insert_self"
on public.profiles
for insert
to authenticated
with check (id = auth.uid() and role = 'viewer'::public.app_role);

create policy "profiles_update_self_or_admin"
on public.profiles
for update
to authenticated
using (id = auth.uid() or public.is_admin())
with check (
  (id = auth.uid() and role = (select role from public.profiles where id = auth.uid()))
  or public.is_admin()
);

create policy "profiles_delete_admin_only"
on public.profiles
for delete
to authenticated
using (public.is_admin());

-- Operator/admin writes.
create policy "agents_write_operator_admin"
on public.agents
for all
to authenticated
using (public.is_operator_or_admin())
with check (public.is_operator_or_admin());

create policy "commands_write_operator_admin"
on public.commands
for all
to authenticated
using (public.is_operator_or_admin())
with check (public.is_operator_or_admin());

create policy "command_results_write_operator_admin"
on public.command_results
for all
to authenticated
using (public.is_operator_or_admin())
with check (public.is_operator_or_admin());

create policy "events_write_operator_admin"
on public.events
for all
to authenticated
using (public.is_operator_or_admin())
with check (public.is_operator_or_admin());
